[toc]


# 练习0:填写已有实验


# 练习1:加载应用程序并执行

# 练习2：父进程复制自己的内存空间给子进程

# 练习3：理解进程执行 fork/exec/wait/exit 的实现

# 补充:用户进程的特征
- **从内核线程到用户进程**  
内核线程的管理实现相对是简单的,其特点是直接使用操作系统(比如ucore)在初始化中建立的内核虚拟内存地址空间,不同的内核线程之间可以通过调度器实现线程间的切换,达到分时使用CPU的目的.由于`内核虚拟内存空间是一一映射计算机系统的物理空间的,这使得可用空间的大小不会超过物理空间大小`,所以操作系统程序员编写内核线程时,需要考虑到有限的地址空间,需要保证各个内核线程在执行过程中不会破坏操作系统的正常运行.这样`在实现内核线程管理时,不必考虑涉及与进程相关的虚拟内存管理中的缺页处理、按需分页、写时复制、页换入换出等功能`.如果在内核线程执行过程中出现了访存错误异常或内存不够的情况,就认为操作系统出现错误了,操作系统将直接宕机.在ucore中,就是调用panic函数,进入内核调试监控器kernel_debug_monitor.  
<br/>

操作系统程序员需要给应用程序员编写的程序提供一个既"宽松"又"严格"的执行环境,让对内存大小和CPU使用时间等资源的限制没有仔细考虑的应用程序都能在操作系统中正常运行,且即使程序不可靠,也只能破坏自己,而不能破坏其他运行程序和整个系统.  
`严格`就是安全性保证,即应用程序执行不会破坏在内存中存在的其他应用程序和操作系统的内存空间等独占的资源;  
`宽松`就算是方便性支持,即提供给应用程序尽量丰富的服务功能和一个远大于物理内存空间的虚拟地址空间,使得应用程序在执行过程中不必考虑很多繁琐的细节(比如如何初始化PCI总线和外设等、如何管理物理内存等).  

- **让用户进程正常运行的用户环境**  
从操作系统的设计和实现的角度看,其实用户进程是指一个应用程序在操作系统提供的一个用户环境中的一次执行过程.操作系统提供的这个用户环境有两方面的特点:  
一方面与存储空间相关,即限制用户进程可以访问的物理地址空间,且让各个用户进程之间的物理内存空间访问不重叠,这样可以保证不同用户进程之间不能相互破坏各自的内存空间,利用虚拟内存的功能(页换入换出)给用户进程提供了远大于实际物理内存空间的虚拟内存空间;  
另一方面与执行指令相关,即限制用户进程可执行的指令,不能让用户进程执行特权指令(比如修改页表起始地址),从而保证用户进程无法破坏系统.但如果不能执行特权指令,则很多功能(比如访问磁盘等)无法实现,所以需要提供某种机制,让操作系统完成需要特权指令才能做的各种服务功能,给用户进程一个"服务窗口",用户进程可以通过这个"窗口"向操作系统提出服务请求,由操作系统来帮助用户进程完成需要特权指令才能做的各种服务.另外,还要有一个"中断窗口",让用户进程不主动放弃使用CPU时,操作系统能够通过这个"中断窗口"强制让用户进程放弃使用CPU,从而让其他用户进程有机会执行.  
<br/>

可以把这个用户环境定义为如下组成部分:  
1.建立用户虚拟空间的页表和支持页换入换出机制的用户内存访存错误异常服务例程:提供地址隔离和超过物理空间大小的虚存空间;  
2.应用程序执行的用户态CPU特权级:在用户态CPU特权级,应用程序只能执行一般指令,如果特权指令,结果不是无效就是产生"执行非法指令"异常;  
3.系统调用机制:给用户进程提供"服务窗口"(系统调用其实也是通过中断/异常实现);  
4.中断响应机制:给用户进程设置"中断窗口",这样产生中断后,当前执行的用户进程将被强制打断,CPU控制权将被操作系统的中断服务例程使用;  


- **用户进程的执行过程分析**  
当产生外设中断、CPU执行异常(比如访存错误)、陷入(系统调用)、用户进程就会切换到内核中的操作系统中来.表面上看,到内核态后,操作系统取得了CPU控制权,所以现在执行的应该是操作系统代码,由于此时CPU处于核心态特权级,所以操作系统的执行过程就应该是内核进程了.这样理解忽略了操作系统的具体实现,如果考虑操作系统的具体实现,应该如果来理解进程呢?(下述只是两种稍微不同的观点,不存在对错区别)
<br/>

从进程控制块的角度看,`如果执行了进程执行现场(上下文)的切换,就认为到另外一个进程执行了`,即进程的分界点设定在执行进程切换的前后.到底切换了什么呢?其实`只是切换了进程的页表和相关硬件寄存器`,这些信息都保存在进程控制块中的相关域中.所以,我们可以把执行应用程序的代码一直到执行操作系统中的进程切换处为止都认为是一个应用程序的执行过程即进程。因为在这个过程中,没有更换到另外一个进程控制块的进程的页表和相关硬件寄存器.  
<br/>

从指令执行的角度看,操作系统的主要功能是给上层应用提供服务,管理整个计算机系统中的资源.操作系统需要响应的事件包括三类:`外设中断、CPU执行异常(比如访存错误)、陷入(系统调用)`.  
如果用户进程通过`系统调用`要求操作系统提供服务,那么用户进程的角度看,操作系统就是一个特殊的软件库(比如相对于用户态的libc库,操作系统可看作是内核态的libc库),完成用户进程的需求.从执行逻辑上看,是用户进程"主观"执行的一部分,即用户进程"知道"操作系统要做的事情.那么在这种情况下,进程的代码空间包括用户态的执行程序和内核态响应用户进程通过系统调用而在核心特权态执行服务请求的操作系统代码,为此这种情况下的进程的内存虚拟空间也包括两部分:用户态的虚地址空间和核心态的虚地址空间.  
但如果此时发生的事件是`外设中断和CPU执行异常`,虽然CPU控制权也转入到操作系统中的中断服务例程,但这些内核执行代码执行过程是用户进程"不知道"的,是另外一段执行逻辑.那么在这种情况下,实际上是执行了两段目标不同的执行程序,一个是代表应用程序的用户进程,一个是代表中断服务例程处理外设中断和CPU执行异常的内核线程.这个用户进程和内核线程在产生中断或异常的时候,CPU硬件就完成了它们之间的指令流切换.  


- **用户进程的运行状态分析**  
一个用户进程一般的运行状态有五种:创建(new)态、就绪(ready)态、运行(running)态、等待(blocked)态、退出(exit)态.各个状态之间会由于发生了某事件而进行状态转换.  
`创建`:操作系统完成进程的创建工作,而体现进程存在的就是进程控制块,所以一旦操作系统创建了进程控制块,则可以认为此时进程就已经存在了,但由于进程能够运行的各种资源还没准备好,所以此时的进程处于创建(new)态.  
`就绪`:创建了进程控制块后,进程并不能就执行了,还需准备好各种资源,如果把进程执行所需要的虚拟内存空间,执行代码,,要处理的数据等都准备好了,则此时进程已经可以执行了,但还没有被操作系统调度,需要等待操作系统选择这个进程执行,于是把这个做好"执行准备"的进程放入到一个队列中,并可以认为此时进程处于就绪(ready)态.  
`运行`:当操作系统的调度器从就绪进程队列中选择了一个就绪进程后,通过执行进程切换,就让这个被选上的就绪进程执行了,此时进程就处于运行(running)态了.到了运行态后,会出现三种事件(如下=> 状态分别转换到阻塞/退出/就绪).  
`等待/阻塞`:如果进程需要等待某个事件(比如主动睡眠10秒钟;或进程访问某个内存空间,但此内存空间被换出到硬盘swap分区中了,进程不得不等待操作系统把缓慢的硬盘上的数据重新读回到内存中),那么操作系统会把CPU给其他进程执行,并把进程状态从运行(running)态转换为等待(blocked)态.  
`退出`:如果用户进程的应用程序逻辑流程执行结束了,那么操作系统会把CPU给其他进程执行,并把进程状态从运行(running)态转换为退出(exit)态,并准备回收用户进程占用的各种资源,当把表示整个进程存在的进程控制块也回收了,这进程就不存在了.在这整个回收过程中,进程都处于退出(exit)态.  
考虑到在内存中存在多个处于就绪态的用户进程,但只有一个CPU,所以为了公平起见,每个就绪态进程都只有有限的时间片段,当一个运行态的进程用完了它的时间片段后,操作系统会剥夺此进程的CPU使用权,并把此进程状态从运行(running)态转换为就绪(ready)态,最后把CPU给其他进程执行.如果某个处于等待(blocked)态的进程所等待的事件产生了(比如睡眠时间到,或需要访问的数据已经从硬盘换入到内存中),则操作系统会通过把等待此事件的进程状态从等待(blocked)态转到就绪(ready)态.这样进程的整个状态转换形成了一个有限状态自动机.  
<br/>
除上面外,如果进程被换出到外存,则处于挂起状态......  





# 补充：用户进程管理
## 实验执行流程概述
由于进程的执行空间扩展到了用户态空间,且出现了创建子进程执行应用程序等与lab4有较大不同的地方,所以具体实现的不同主要集中在`进程管理和内存管理`部分.初始化的总控函数kern_init没有任何变化,但这并不意味着lab4与lab5差别不大.其实kern_init调用的物理内存初始化,进程管理初始化等都有一定的变化.  
<br/>

在`内存管理`部分,与lab4最大的区别就是增加用户态虚拟内存的管理.`为了管理用户态的虚拟内存,需要对页表的内容进行扩展,能够把部分物理内存映射为用户态虚拟内存`.如果某进程执行过程中,CPU在用户态下执行(在CS段寄存器最低两位包含有一个2位的优先级域,如果为0,表示CPU运行在特权态;如果为3,表示CPU运行在用户态),则可以访问本进程页表描述的用户态虚拟内存,但由于权限不够,不能访问内核态虚拟内存.另一方面,不同的进程有各自的页表,所以即使不同进程的用户态虚拟地址相同,但由于页表把虚拟页映射到了不同的物理页帧,所以不同进程的虚拟内存空间是被隔离开的,相互之间无法直接访问.在用户态内存空间和内核态内核空间之间需要拷贝数据,让CPU处在内核态才能完成对用户空间的读或写,为此需要设计专门的拷贝函数(copy_from_user和copy_to_user)完成.但反之则会导致违反CPU的权限管理,导致内存访问异常.  
<br/>

在`进程管理`方面,主要涉及到的是进程控制块中与内存管理相关的部分,包括建立进程的页表和维护进程可访问空间(可能还没有建立虚实映射关系)的信息、加载一个ELF格式的程序到进程控制块管理的内存中的方法、在进程复制(fork)过程中、把父进程的内存空间拷贝到子进程内存空间的技术;&nbsp;&nbsp;另外一部分与用户态进程生命周期管理相关,包括让进程放弃CPU而睡眠等待某事件、让父进程等待子进程结束、一个进程杀死另一个进程、给进程发消息、建立进程的血缘关系链表.  
<br/>

当实现了上述内存管理和进程管理的需求后,接下来ucore的用户进程管理工作就比较简单了.首先,"硬"构造出第一个进程(lab4中已有描述),它是后续所有进程的祖先; &nbsp;然后,在proc_init函数中,通过alloc把当前ucore的执行环境转变成idle内核线程的执行现场; &nbsp;然后调用kernl_thread来创建第二个内核线程init_main,而init_main内核线程又创建了user_main内核线程.到此,内核线程创建完毕,应该开始用户进程的创建过程,这第一步实际上是通过user_main函数调用kernel_tread创建子进程,通过kernel_execve调用来把某一具体程序的执行内容放入内存.具体的放置方式是根据ld在此文件上的地址分配为基本原则,把程序的不同部分放到某进程的用户空间中,从而通过此进程来完成程序描述的任务.一旦执行了这一程序对应的进程,就会从内核态切换到用户态继续执行.以此类推,CPU在用户空间执行的用户进程,其地址空间不会被其他用户的进程影响,但由于系统调用(用户进程直接获得操作系统服务的唯一通道)、外设中断和异常中断的会随时产生,从而间接推动了用户进程实现用户态到到内核态的切换工作.ucore对CPU内核态与用户态的切换过程需要比较仔细地分析(这其实是实验一的扩展练习).当进程执行结束后,需回收进程占用和没消耗完毕的设备整个过程,且为新的创建进程请求提供服务.在本实验中,当系统中存在多个进程或内核线程时,ucore采用了一种FIFO的很简单的调度方法来管理每个进程占用CPU的时间和频度等.在ucore运行过程中,由于调度、时间中断、系统调用等原因,使得进程会进行切换、创建、睡眠、等待、发消息等各种不同的操作,周而复始、生生不息.
## 创建用户进程
## 进程退出和等待进程
## 系统调用实现

